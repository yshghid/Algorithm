# Lec10. Networkflow

## 유량 네트워크 (Flow network)

<img src="https://github.com/yshghid/Algorithm/assets/153489198/d48e3832-3eb9-412d-968b-36847a6b4ddf" alt="Flow Network" width="600">

- G = (V, E, s, t, c)
- 소스(source) s ∈ V와 싱크(sink) t ∈ V가 존재하는 방향 그래프 (V, E); 모든 노드가 s로부터 도달 가능한 것으로 가정함.
- e ∈ E 일때 용량 c(e) ≥ 0.
- 직관적 정의: 운송 네트워크를 통한 재료의 흐름. 재료는 소스에서 발생하여 싱크로 보내진다.

## 최소 절단 문제 (Minimum-cut problem)

- st-cut은 노드 집합 V를 두 부분으로 나누는 것이다. 하나의 부분 집합에는 노드 s가 포함되고, 다른 부분 집합에는 노드 t가 포함된다.
- cut의 용량은 A에서 B로 가는 에지들의 용량의 합이다.

<image src="https://github.com/yshghid/Algorithm/assets/153489198/ac535761-d3e3-4475-9982-f2b1f991b8e2" width = "600">

- 위 그림에서 {s} = A, {1,2,3,4,5,6,t} = B
- st-cut의 용량: 10(s→1) + 5(s→3) + 15(s→5) = 30

<img src="https://github.com/yshghid/Algorithm/assets/153489198/abe1a54d-8cee-4fe3-974a-c0d76062bcb8" width = "600">

- 위 그림에서 {s, 3, 5, 6} = A, {1, 2, 4, t} = B
- st-cut의 용량: 10(s→1) + 8(3→4) + 10(6→t) = 28

## 최대 유량 문제 (Maximum-flow problem)

최대 유량 문제는 소스 s에서 싱크 t로 가는 최대 값을 가진 유량 f를 찾는 것이다.

### 그리디 알고리즘으로 최대 유량 찾기

<img src="https://github.com/yshghid/Algorithm/assets/153489198/ccb9c791-78cb-4dda-af7d-ac62989401b0" width=600>

그림에서 최대 유량을 그리디 알고리즘으로 찾기. 

1. 초기 상태: 모든 e∈E 에 대해 f(e)는 0으로 시작한다.

2. 첫번째 증가 경로: 양수 잔여 용량이 있는 경로를 찾는다. 즉 각 에지에서 f(e)<c(e) 인 경로를 찾는다.

- 경로 s->1->4->t
- 경로의 최소 잔여 용량: min(10, 8, 10) = 8
- 경로를 따라 유량이 8 증가: f(s->1) = 8, f(1->4) = 8, f(4->t) = 8

3. 잔여 용량 업데이트

<img src="https://github.com/yshghid/Algorithm/assets/153489198/aea266f9-03f9-4a5e-87b5-e329a6bbea5c" width=600>

- s->1의 잔여 용량은 2(10-8)
- 1->4의 잔여 용량은 0(8-8)
- 4->t의 잔여 용량은 2(10-8)
- 흐름 f(s->1): 8

4. 반복: 더 이상 증가 경로를 찾을 수 없을 때까지 증가 경로를 찾고 유량을 증가시킨다.

<img src="https://github.com/yshghid/Algorithm/assets/153489198/cddf49ad-52ed-414c-aaab-a5a49fd3c3ff" width=600>

- 두번째 증가 경로: s->1->3->4->t
- 경로를 따라 유량이 2 증가: f(s->1) = 10, f(1->3) = 2, f(3->4)=2, f(4->t) = 10
- 유량 f(s->1): 10

<img src="https://github.com/yshghid/Algorithm/assets/153489198/ce3d0898-8e22-498f-aebd-87c112ed64d9" width=600>

- 세번째 증가 경로: s->3->4->2->t
- 경로를 따라 유량이 6 증가: f(s->3) = 6, f(3->4) = 8, f(4->2) = 6, f(2->t) = 6
- 유량 f(s->2): 6

5. 최종 유량 값

- 소스 s에서 나가는 유량 합은 최종 유량 값이다. 이 경우, val(f) = f(s->1) + f(s->2) = 10+6 = 16

6. 하지만, 주어진 그래프에서 s에서 t로 가는 최대 유량은 19이다.

<img src="https://github.com/yshghid/Algorithm/assets/153489198/32202c59-794c-4cc6-855c-727ad91724b7" width=600>

### 그리디 알고리즘이 실패하는 이유

Q: 그리디 알고리즘이 실패하는 이유는?

A: 한 번 에지에 유량을 증가시키면 이를 다시 줄일 수 없기 때문. 이는 잘못된 경로를 선택했을 때 최적의 해결책을 찾을 수 없게 만든다. 

<img src="https://github.com/yshghid/Algorithm/assets/153489198/f92d9a6d-5dab-4b87-99a2-652f145ddd67" width=600>

예시 네트워크 유량 그래프 G.

- 그리디 알고리즘은 가능한 용량이 있는 아무 증가 경로를 찾기 때문에, 첫 번째 경로로 s→v→w→t를 선택하였다.
- 그리디 알고리즘이 s->v->w->t 경로를 통해 f(s->v) = 1, f(v->w) = 1, f(w->t) = 1의 유량을 보낸다면, v->w 에지의 용량이 모두 소모되어 유일한 최대 유량 f*(v, w) = 0을 가진다.
- 올바른 최대 유량은 v->w 에지를 사용하지 않는 다른 구성을 사용해야 함.
- 그리디 알고리즘이 특정 엣지에 유량을 잠그면 최적의 해결책을 찾을 수 없게 되므로 잘못된 결정을 "되돌릴" 수 있는 메커니즘이 필요.

### 잔여 네트워크 (Residual network)

<img src="https://github.com/yshghid/Algorithm/assets/153489198/913302ff-b39b-4575-990b-0fbfb7ca0855" width=300>

- 유량 네트워크 G에서 원래 에지 e가 갖는 특성은 유량 f(e) (해당 엣지를 통과하는 현재 유량), 용량 c(e)(해당 엣지가 처리할 수 있는 최대 유량)이다.
- 잔여 네트워크 Gf는 역 에지 e(reverse)를 갖는다. 역 에지는 원래 엣지 e를 통해 보낸 유량을 "되돌리는" 것을 허용한다.
- 잔여 네트워크의 원래 에지 e의 잔여 용량 cf(e) = c(e) - f(e) 는 원래 방향으로 유량을 증가시킬 수 있는 남은 용량을 나타낸다. 
- 잔여 네트워크의 역 에지 e의 잔여 용량 cf(e(reverse)) = f(e) 는 역 방향으로 유량을 줄일 수 있는 용량을 나타낸다.

### 증가 경로 (Augmenting Path)와 병목 용량 (bottleneck capacity)

- 증가 경로: 잔여 네트워크 Gf 에서의 단순 s->t 경로. ("단순": 경로에 사이클이 없음, 각 노드는 최대 한 번만 방문된다)
- 병목 용량: 증가 경로 P의 어떤 에지에서의 최소 잔여 용량.

```
s --(6)--> u --(3)--> v --(6)--> t
  <--[4]--   <--[2]--   <--[2]--
```
- 현재 유량 f는 [4, 2, 2] 이다이고 잔여 용량은 (6, 3, 6) 이다.
```
# 유량을 3만큼 증가시킴
s --(3)--> u --(0)--> v --(3)--> t
  <--[7]--   <--[5]--   <--[5]--
```
- 유량 f가 주어지고, P가 잔여 네트워크 Gf에서의 증가 경로일때, P를 따라 병목 용량 3만큼 유량을 증가시키면, 결과 유량 f'는 여전히 유효한 유량이다.
```
# 유량을 4만큼 증가시킴
s --(2)--> u --(-1)--> v --(2)--> t
  <--[8]--   <--[6]--   <--[6]--
```
- 만약 병목 용량보다 크게 4만큼 유량을 증가시키면, 결과 유량 f는 유효하지 않은 유량이다. u->v 에지의 유량이 에지의 용량인 5를 초과하여 용량 제약을 위반한다.

```
val(f') = val(f) + bottleneck(Gf,P)
```
- 새로운 흐름 f'의 값은 원래 유량 f에 병목 용량을 더한 것과 같다.

### 퍼드 포커슨 알고리즘으로 최대 유량 찾기

<img src="https://github.com/yshghid/Algorithm/assets/153489198/2f2c8bb4-5213-4a4c-b36c-2763f9a64616" width=600>

그림에서 최대 유량을 퍼드 포커슨 알고리즘으로 찾기.

1. 초기 상태: 모든 e∈E 에 대해 f(e)는 0으로 시작한다.

2. 첫번째 증가 경로 찾기

- 경로 s->1->4->t
- 병목 용량: min(10, 8, 10) = 8
- 경로를 따라 유량이 8 증가: f(s->1) = 8, f(1->4) = 8, f(4->t) = 8
- 경로를 따라 유량이 8 감소: f(1->2) = 2, f(4->1) = 0, f(t->4) = 2
- 유량 f(s->t): 8

3. 잔여 네트워크 업데이트

```
# 첫번째 증가 경로의 잔여 네트워크 업데이트
s --(2)--> 1 --(0)--> 4 --(2)--> t
  <--[8]--   <--[8]--   <--[6]--
```
- 업데이트된 잔여 네트워크
<img src="https://github.com/yshghid/Algorithm/assets/153489198/d31d1ea9-da5f-4c91-94b9-2fbf8bbe016b)" width=600>

4. 반복: 더 이상 증가 경로를 찾을 수 없을 때까지 증가 경로를 찾고 유량을 증가시킨다.

- 두번째 증가 경로: s->1->3->4->t
- 병목 용량: min(2, 2, 9, 2) = 2
- 경로를 따라 유량이 2 증가: f(s->1) = 10, f(1->3) = 2, f(3->4)=2, f(4->t) = 10
- 경로를 따라 유량이 2 감소: f(1->s) = 0, f(1->3) = 0, f(3->4)=7, f(4->t) = 0
- 유량 f(s->t): 8+2=10
- 잔여 네트워크 업데이트

```
# 두번째 증가 경로의 잔여 네트워크 업데이트
s --(0)--> 1 --(0)--> 3 --(7)--> 4 --(0)--> t
  <--[10]--   <--[2]--   <--[2]--   <--[10]--
```
- 업데이트된 잔여 네트워크
<img src="https://github.com/yshghid/Algorithm/assets/153489198/73c97a15-38ec-4e18-b676-e634ec8c7143)" width=600>

- 세번째 증가 경로: s->3->4->2->t
- 병목 용량: min(10,7,6,10) = 6
- 경로를 따라 유량이 6 증가: f(s->3) = 6, f(3->4) = 8, f(4->2) = 6, f(2->t) = 6
- 경로를 따라 유량이 6 감소: f(3->s) = 4, f(3->4) = 1, f(4->2) = 0, f(2->t) = 4
- 유량 f(s->t): 10+6=16
- 잔여 네트워크 업데이트
```
# 세번째 증가 경로의 잔여 네트워크 업데이트
s --(4)--> 3 --(1)--> 4 --(0)--> 2 --(4)--> t
  <--[6]--   <--[8]--   <--[6]--   <--[6]--
```
- 업데이트된 잔여 네트워크
<img src="https://github.com/yshghid/Algorithm/assets/153489198/05512e1a-16ce-49b9-8620-2ab3a59563a5" width=600>

- 네번째 증가 경로: s->3->1->2->t 
- 병목 용량: min(4,2,4,4) = 2
- 경로를 따라 유량이 2 증가: f(s->3) = 8, f(3->1) = 2, f(1->2) = 2, f(2->t) = 8
- 경로를 따라 유량이 2 감소: f(3->s) = 2, f(1->3) = 0, f(2->1) = 3, f(t->2) = 2
- 유량 f(s->t): 16+2=18
- 잔여 네트워크 업데이트
```
# 네번째 증가 경로의 잔여 네트워크 업데이트
s --(2)--> 3 --(0)--> 1 --(3)--> 2 --(2)--> t
  <--[8]--   <--[2]--   <--[2]--   <--[8]--
```
- 업데이트된 잔여 네트워크
<img src="https://github.com/yshghid/Algorithm/assets/153489198/1c27ff3b-d9c8-4ba1-abf4-b3c40aedcffb" width=600>

cf) 네번째 업데이트의 효과: (3->1) 로 유량을 2 증가시키는 것은 (1->3) 으로 유량을 -2 증가시키는 것과 같기 때문에 두번째 업데이트에서 (1->3) 으로 유량 2 증가되었던 것이 취소되었다.

- 다섯번째 증가 경로: s->3->4->1->2->t
- 병목 용량: min(2,1,8,,2) = 1
- 경로를 따라 유량이 1 증가: f(s->3) = 9, f(3->4) = 9, f(4->1) = 1, f(1->2) = 3, f(2->t) = 9
- 경로를 따라 유량이 1 감소: f(3->s) = 1, f(4->3) = 0, f(1->4) = 7, f(2->1) = 1, f(t->2) = 1
- 유량 f(s->t): 18+1=19
- 잔여 네트워크 업데이트
```
# 다섯번째 증가 경로의 잔여 네트워크 업데이트
s --(1)--> 3 --(0)--> 1 --(7)--> 2 --(1)--> 2 --(1)--> t
  <--[9]--   <--[9]--   <--[1]--   <--[3]--   <--[9]--
```
- 업데이트된 잔여 네트워크
<img src="https://github.com/yshghid/Algorithm/assets/153489198/f354818f-dee7-4338-9a62-7ca5b70c6e0f" width=600>

cf) 다섯번째 업데이트의 효과: (4->1) 로 유량을 1 증가시키는 것은 (1->4) 으로 유량을 -1 증가시키는 것과 같기 때문에 첫번째 업데이트에서 (1->4) 으로 유량 7 증가되었던 것이 1만큼 취소되었다.

5. 최종 유량 값: 19
<img src="https://github.com/yshghid/Algorithm/assets/153489198/c98e9d72-0fad-44a0-997b-5b15de2b3755" width=600>

- 유량 네트워크에서 최대 유량과 최소 컷의 용량이 같음을 확인할 수 있다.

```
FORD–FULKERSON(G)
FOREACH edge e∈ E: f(e) ← 0.
Gf ← residual network of G with respect to flow f.
WHILE (there exists an s↝t path P in Gf)
  f ← AUGMENT(f,c,P).
  Update Gf.
RETURN f.

AUGMENT(f,c,P)
FOREACH edge e∈P :
  IF (e∈E) f(e) ← f(e) + δ.
  ELSE f(e_reverse) ← f e_reverse) – δ.
RETURN f.
```

## 최소 컷 최대 유량 정리 (Max-flow min-cut theorem)

- 최대 유량: 네트워크에서 소스에서 싱크로 보낼 수 있는 최대 유량
- 최소 컷: 노드 집합 V를 A, B로 나눌 때, A에서 B로 가는 에지들의 용량의 합이 최소가 되도록 나누는 컷

### 유량 보조정리 (Flow value lemma)

- 임의의 유량 f와 임의의 컷 (A,B)가 주어졌을 때, 유량 f(소스에서 싱크로 흐르는 총 유량)는 컷 (A,B)를 통해 흐르는 순 유량(net flow across cut)과 같다.
- 컷 (A,B)를 통해 흐르는 순 유량 (net flow accross cut (A,B)): (A->B 로 흐르는 유량의 합) - (B->A 로 흐르는 유량의 합)

<img src="https://github.com/yshghid/Algorithm/assets/153489198/ec31ba6e-28d3-47ef-ac30-619261edf432" width=600>

- 위 네트워크에서 {s,2,3,4} = A, {1,5,6,t} = B
- 순 유량(net flow across cut): (10 + 10 + 5 + 10 + 0 + 0) – (5 + 5 + 0 + 0) = 25
- 총 유량: 25

### 약한 대우성 (Weak duality)

- 유량 f와 컷 (A,B)에 대해, 유량의 값 val(f)은 컷의 용량 cap(A,B)보다 작거나 같다.

### 최적성 보장 (Certificate of optimality)

- 유량 f와 컷 (A,B)에 대해, val(f) = cap(A,B) 라면 f는 최대 유량이고 (A,B)는 최소 컷이다.

- 두 가지 조건이 증명됨을 보이기.
1. val(f) = cap(A,B)일때, f는 최대 유량이다.
2. val(f) = cap(A,B)일때, (A,B)는 최소 컷이다.

- 1 증명: weak duality에 따라, 임의의 유량 f'에 대해 val(f') <= cap(A,B) 이다. 따라서 val(f') <= cap(A,B) = val(f) 이므로 val(f) = cap(A,B)일때, f는 최대 유량이다.
- 2 증명: weak duality에 따라, 임의의 컷 (A',B')에 대해 cap(A',B') >= cap(A,B) 이다. cap(A,B)는 네트워크의 최대 유량과 같기 때문이다. 따라서, cap(A',B') >= val(f) = cap(A,B) 이므로 val(f) = cap(A,B)일때, (A,B)는 최소 컷이다.

### 최소 컷 최대 유량 정리 증명 (Max-flow min-cut theorem)

- 세 가지 조건이 동등함을 보이기.
1. cap(A,B) = val(f) 인 컷 (A,B)가 존재한다.
2. f가 최대 유량이다.
3. 잔여 네트워크에서 증가 경로(augmenting path)가 없다.

- 2가 3을 포함함을 증명: 증가 경로가 있다고 가정하면, 그 경로를 따라 유량을 증가시킬 수 있으며, 유량이 증가되었으므로 기존 유량 f는 최대 유량이 아님. 따라서, 증가 경로가 존재하면 f가 최대 유량이 아니므로, f가 최대 유량이라면 잔여 네트워크에서 증가 경로가 없다.
- 3이 1을 포함함을 증명: 증가 경로가 없는 잔여 네트워크에서의 유량 f와, 잔여 네트워크 Gf에서 소스 s로부터 도달 가능한 노드 집합 A, 나머지 노드 집합 B가 있다. f의 정의에 따라 A에 t는 포함되지 않는다. 잔여 네트워크에서 v∈A,w∈B 인 에지 e=(v,w)는 f(e)=c(e)여야 하므로 컷의 용량 cap(A,B)는 A->B 인 에지들의 용량의 합이다. s->t로 가는 유량의 값인 val(f)는 A->B 인 에지들의 유량(c(e))의 합과 같다. 따라서 cap(A,B) = val(f) 이다, 즉 잔여 네트워크에서 증가 경로가 없으면 컷의 용량이 유량의 값과 같다.
- 1이 2를 포함함을 증명: cap(A,B) = val(f)인 컷 (A,B)가 존재한다고 가정하면, 임의의 유량 f'에 대해 val(f')<=cap(A,B)이다(약한 대우성). 따라서, val(f')<=val(f) 이므로 f는 최대 유량이다. 그러므로 컷의 용량이 유량의 값과 같으면 f는 최대 유량이다.
- 따라서 세 가지 조건이 동등하다.


### 최대 유량으로 최소 컷 계산하기 (Computing a minimum cut from a maximum flow)

- 최대 유량 값으로 최소 컷을 시간 복잡도 O(m) 안에 구할 수 있다. 최대 유량이 주어졌을 때, 잔여 네트워크 Gf 에서 노드 s로부터 도달 가능한 모든 노드 집합 A를 만들고 나머지 노드 집합을 B로 정의한다. A->B 인 에지의 용량 합이 최소 컷의 용량이다.

## 퍼드 포커슨 알고리즘 분석

### 모든 에지 용량이 정수일 때

- 모든 에지 용량 c(e)는 1과 C 사이 정수일때 다음을 만족한다.

1. 정수 불변성 (Integrality Invariant): Ford-Fulkerson 알고리즘을 실행하는 동안, 모든 에지의 유량 f(e)과 잔여 용량 cf(e)는 정수이다.
2. 퍼드 포커슨 알고리즘은 val(f)가 최대 유량 val(f*)일때 종료되므로 최대 C번의 증가 경로를 찾은 후 종료된다. 최대 유량 val(f*)는 에지의 최대 용량 C보다 작거나 같기 때문이다. 
3. 시간 복잡도: 퍼드 포커슨 알고리즘의 시간 복잡도는 O(mC)이다. m은 에지의 수, C는 최대 용량일때 각 증가 경로를 찾는 데 O(m)의 시간이 걸리고, 최대 C번의 증가 경로를 찾기 때문이다.

- 결론: 퍼드 포커슨 알고리즘은 정수 용량 네트워크에서 최대 유량을 O(mC) 안에 찾을 수 있다. 각 단계에서 증가 경로를 찾고 유량을 증가시키는 과정을 반복해서, 알고리즘은 최대 C번의 증가 경로를 찾은 후 종료된다. 이 과정에서 유량과 잔여 용량은 항상 정수로 유지된다.

### 다항 시간 내에 종료되는가?

<img src="https://github.com/yshghid/Algorithm/assets/153489198/50f4537d-f677-443b-918f-651cec74d352" width=600>

- 위 유량 네트워크에서 s->v->w->t 와 s->w->v->t 경로가 교대로 선택되며 유량을 1씩 증가시킨다. 최대 유량 c(f*)에 도달하기 위해 2C번의 반복이 필요하다.
- 퍼드 포커슨 알고리즘은 모든 에지 용량이 정수일 때 O(mC) 시간 내에 최대 유량을 찾을 수 있지만, 특정 조건에서는 알고리즘이 C의 차수만큼 반복되어 증가 경로의 수가 최대 용량 C에 비례하여 기하급수적으로 증가하므로 다항 시간 내에 종료되지 않을 수 있다.

### 올바른 증가 경로 선택하기

- 병리적 예시: 에지 용량이 무리수일 때, 선택된 증가 경로에 따라 퍼드 포커슨 알고리즘은 종료되지 않을 수도 있다.
- 효율적으로 증가 경로를 찾고, 반복 횟수를 최소화하는 것이 중요하다.
  
<img src="https://github.com/yshghid/Algorithm/assets/153489198/ef669da5-7c7b-4bcf-9d46-43920f1c4330" width=600>

- 위 유량 네트워크에서, C는 매우 큰 값(무한대)이고 r은 매우 작은 무리수이다.
- 증가 경로가 선택되면서 유량은 r씩 증가한다. 계속해서 작은 증가 경로를 선택하게 되면 유량의 값은 1 + 2r + 2r^2 + 2r^3 + ... + 형태로 증가한다. 즉 무한히 작은 유량이 계속해서 더해지면서 알고리즘이 종료되지 않을 수 있다.
- 무리수 용량 r을 가진 경로를 k번 선택한 후 유량의 총 증가 수식
<img src="https://github.com/yshghid/Algorithm/assets/153489198/0b1c66a8-c83e-4c7a-a9ad-2026763bb3e0" width=600>

### 용량-스케일링 알고리즘

- 퍼드 포커슨 알고리즘의 변형으로, "큰" 병목 용량을 가진 증가 경로를 선택하여 효율성을 높인다.
- 최소 병목 용량 Δ 를 정해서, 용량이 Δ 이상인 에지만 포함하는 부분 잔여 네트워크 Gc(Δ)를 사용해서 병목 용량이 Δ 이상인 증가 경로를 선택한다.

#### 정확성 증명

- 불변성 1: Δ 는 2의 거듭제곱 형태이다.
- 불변성 2: 알고리즘 동안 모든 에지의 유량 f(e)와 잔여 용량 cf(e)는 정수이다.
- 증명: Δ는 최대 용량보다 큰 2의 거듭제곱으로 초기화되고, 증가 경로를 찾으면서 잔여 네트워크가 갱신된다. Δ=1일 때, Gf(Δ)는 Gf와 동일하다. Δ=1이 종료되면, 잔여 네트워크 Gf에서 더이상 증가 경로가 없으므로 현재 유량 f가 최대 유량이다. 따라서, 용량-스케일링 알고리즘이 종료되면, f는 최대 유량이다.

#### 시간 복잡도 증명

- 보조정리 1: 스케일링 단계의 수는 1+⌊log 2C⌋ 이다.
- 보조정리 2: 각 스케일링 단계에서 유량 v(f)는 최소 Δ만큼 증가한다.
- 보조정리 3: Δ-스케일링 단계가 끝났을 때 유량 f가 최소 유량이면, 최대 유량 값은 val(f)+mΔ 이하이다.
- 보조정리 4: 각 스케일링 단계에서 최대 2m번의 증가 경로가 필요하다.
- 용량 복잡도 알고리즘의 시간 복잡도 계산하기: 총 증가 경로의 수는 O(mlogC)이다. 각 증가 경로를 찾는 데 O(m) 시간이 걸린다. 따라서 전체 알고리즘의 시간 복잡도는 O(m^2logC)이다.





